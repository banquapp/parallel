'use strict';

/**
 * Run async `action` on data generated by `iterableInput` in `concurrentTasksLimit` concurrent processes
 *
 * @template TInput
 * @template TOutput
 * @param {AsyncIterableIterator<TInput> | IterableIterator<TInput>} iterableInput
 * @param {number} concurrentTasksLimit
 * @param {(input: TInput, index: number) => Promise<TOutput> | TOutput} action
 * @returns {AsyncIterableIterator<TOutput>}
 */
function processInParallel(iterableInput, concurrentTasksLimit, action) {
	if (!iterableInput || typeof iterableInput.next !== 'function')
		throw new TypeError('iterableInput must be an Iterable Object');
	if (typeof concurrentTasksLimit !== 'number')
		throw new TypeError('concurrentTasksLimit argument must be a Number');
	if (typeof action !== 'function')
		throw new TypeError('action argument must be a Function');

	/** @type {Array<Promise<IteratorResult<TOutput>> | IteratorResult<TOutput>>} */
	const runningTasks = [];
	let inputDone = false;
	let inputIndex = 0;

	/**
	 * @param {{ done: boolean, value: TInput }} input
	 * @returns {Promise<{ done: boolean, value: TOutput }>}
	 */
	const executeActionOnIterableInput = async input => {
		const { done, value } = input;
		if (done) {
			inputDone = true;
			return { done, value: undefined };
		}

		const actionResult = await action(value, inputIndex++);

		return { done, value: actionResult };
	};

	/**
	 * Create async tasks for data pulling from input generator, until the processing queue is full
	 */
	const pullFromInput = () => {
		while (runningTasks.length < concurrentTasksLimit && !inputDone) {
			const input = iterableInput.next();
			const processTask = Promise.resolve(input).then(executeActionOnIterableInput);

			runningTasks.push(processTask);
		}
	};

	return {
		async next() {
			// start processing input once output is requested
			if (runningTasks.length === 0)
				pullFromInput();

			const firstRunningTask = runningTasks.splice(0, 1)[0];
			const { done, value } = await firstRunningTask;

			if (!done)
				pullFromInput();

			return { done, value };
		},
		async return() {
			return { done: true, value: null };
		},
		[Symbol.asyncIterator]() {
			return this;
		}
	};
}

module.exports = processInParallel;
